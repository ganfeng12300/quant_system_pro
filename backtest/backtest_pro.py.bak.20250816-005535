

# === auto add: strategy resolver ===
from importlib import import_module

# === auto override: smarter resolver for A1-A8 aliases ===
from importlib import import_module as _imp
import re as _re

def _resolve_fn(strat_key):
    S = _imp("strategy.strategies_a1a8")
    key = str(strat_key)

    # 1) 直接模块属性
    if hasattr(S, key):
        return getattr(S, key)

    # 2) 常见注册表/字典
    for k in ("STRATEGIES","STRATEGY_FUNCS","STRAT_TABLE","REGISTRY","ALIASES","ALIAS"):
        if hasattr(S, k):
            M = getattr(S, k)
            try:
                if key in M:
                    return M[key]
            except Exception:
                pass

    # 3) 标准 A1~A8 映射（含常见函数名）
    alias = {
        "A1": ["strat_bbands","strat_a1","A1","a1"],
        "A2": ["strat_breakout","strat_a2","A2","a2"],
        "A3": ["strat_rsi","strat_a3","A3","a3"],
        "A4": ["strat_macd","strat_a4","A4","a4"],
        "A5": ["strat_kelly","strat_a5","A5","a5"],
        "A6": ["strat_meanrev","strat_a6","A6","a6"],
        "A7": ["strat_trend","strat_a7","A7","a7"],
        "A8": ["strat_mix","strat_a8","A8","a8"],
        # 便捷别名（GPU）
        "XGB": ["strat_xgb_gpu"],
        "LGBM": ["strat_lgbm_gpu"],
        "LSTM": ["strat_lstm_gpu"],
    }
    up = key.upper()
    if up in alias:
        for name in alias[up]:
            if hasattr(S, name):
                return getattr(S, name)
        # 兜底：A1 找到包含 bbands 的函数名即用
        if up == "A1":
            for name in dir(S):
                if "bbands" in name.lower():
                    return getattr(S, name)

    raise KeyError(f"Unknown strategy: {strat_key}")
# -*- coding: utf-8 -*-
"""
S档回测：Bayes+GA 寻优、全成本（含冲击）、Walk-Forward、Deflated Sharpe、SPA、PBO 报告、
中文报表导出 + best_combo.csv 供实盘使用
"""
import argparse, os, json, time, sqlite3, numpy as np, pandas as pd
from datetime import datetime
from tools.config import get_db_path, get_results_db, runtime_params
from tools.db_util import connect_ro
from tools.fees_rules import fetch_funding_series, apply_costs, estimate_impact_bps
from strategy.strategies_a1a8 import STRATS
from backtest.stats_validators import equity_metrics, walk_forward_splits, deflated_sharpe, spa_significance, probability_of_backtest_overfitting

from hyperopt import fmin, tpe, hp, Trials, STATUS_OK
from deap import base, creator, tools as deap_tools

TFS=["5m","15m","30m","1h","2h","4h","1d"]

# 参数空间（可扩展）
SPACE={
 "A1": {"period": hp.quniform("period",18,34,2), "n": hp.uniform("n",1.2,2.8)},
 "A2": {"fast": hp.quniform("fast",8,16,2), "slow": hp.quniform("slow",40,70,2)},
 "A3": {"period": hp.quniform("period",12,22,2), "low": hp.quniform("low",20,35,1), "high": hp.quniform("high",60,75,1)},
 "A4": {"atr_n": hp.quniform("atr_n",12,22,2), "k": hp.uniform("k",1.2,2.4)},
 "A5": {"lookback": hp.quniform("lookback",20,50,2), "n_estimators": hp.quniform("n_estimators",150,300,50),
        "num_leaves": hp.quniform("num_leaves",31,63,2), "lr": hp.uniform("lr",0.02,0.08)},
 "A6": {"lookback": hp.quniform("lookback",20,50,2), "n_estimators": hp.quniform("n_estimators",200,400,50),
        "max_depth": hp.quniform("max_depth",4,8,1)},
 "A7": {"lookback": hp.quniform("lookback",24,40,2), "hidden": hp.quniform("hidden",16,48,8), "epochs": hp.quniform("epochs",2,4,1)},
 "A8": {"rsi_n": hp.quniform("rsi_n",12,18,2), "rsi_low": hp.quniform("rsi_low",20,30,1), "atr_n": hp.quniform("atr_n",12,18,2), "k": hp.uniform("k",1.2,2.0)},
}

def read_klines(db, table):
    with connect_ro(db) as con:
        try:
            df=pd.read_sql_query(f'SELECT ts, open, high, low, close, volume FROM "{table}" ORDER BY ts ASC', con)
            return df if not df.empty else None
        except Exception:
            return None

def backtest_once(df, strat_key, params, rp, symbol, tf):
    name, fn = STRATS[strat_key]
    fn = _resolve_fn(strat_key); pos = fn(df, **{k:int(v) if isinstance(v,float) and v.is_integer() else float(v) for k,v in params.items()})
    close=pd.to_numeric(df["close"], errors="coerce").astype(float)
    ret = pos.shift(1).fillna(0.0) * close.pct_change().fillna(0.0)

    # 资金费率
    fund_df=None
    if rp["funding_on"]:
        try:
            fund_df=fetch_funding_series(symbol, int(df["ts"].iloc[0]), int(df["ts"].iloc[-1]))
        except Exception:
            fund_df=None

    # 冲击成本估计（以20日平均名义ADV为近似：价格*成交量*bar数）
    adv_usdt = float((close*pd.to_numeric(df["volume"]).fillna(0)).rolling(24*20).mean().dropna().median() or 1e6)
    # 进出时名义按风险预算估算（不精确但一致口径）
    notional_series = pos.diff().abs().fillna(0.0) * (rp["risk_per_trade"]/max(0.004,0.01))  # 风险/止损距离近似→名义
    impact_bps = estimate_impact_bps(notional_series, adv_usdt, kappa=15.0)

    ret = apply_costs(ret, pos, taker_fee=rp["taker_fee"], slippage=rp["slippage"],
                      funding_df=fund_df, bar_ts=df["ts"].tolist(), impact_bps_series=impact_bps)

    eq=(1+ret.fillna(0.0)).cumprod()
    met=equity_metrics(eq)
    trades=int(((pos.diff()!=0)&(pos==1)).sum())
    winrate=float((ret[ret!=0]>0).mean()*100) if trades>0 else np.nan
    return {
        "Symbol":symbol,"时间周期":tf,"策略":strat_key,"参数JSON":json.dumps(params,ensure_ascii=False),
        "总收益(%)":met["总收益(%)"],"年化(%)":met["年化(%)"],"夏普比":met["夏普比"],"胜率(%)":winrate,
        "交易次数":trades,"最大回撤(%)":met["最大回撤(%)"],
        "手续费滑点成本(%)":float(( (rp["taker_fee"]+rp["slippage"])*trades )*100),  # 近似展示
        "资金费率影响(%)":0.0,"冲击成本(%)":float(impact_bps.fillna(0).sum()/100.0),
        "pos":pos, "ret":ret, "eq":eq
    }

def bayes_ga_optimize(df, symbol, tf, strat_key, rp, n_bayes=25, n_ga=20, elite=10):
    space=SPACE[strat_key]
    results=[]
    def objective(p):
        res=backtest_once(df, strat_key, p, rp, symbol, tf)
        score = 0.5*(res["夏普比"]/3.0) + 0.3*(res["总收益(%)"]/100.0) - 0.2*(res["最大回撤(%)"]/50.0)
        results.append(res)
        return {"loss": -score, "status": STATUS_OK}
    trials=Trials()
    fmin(fn=objective, space=space, algo=tpe.suggest, max_evals=n_bayes, trials=trials, rstate=np.random.default_rng(42))

    # 取精英解做 GA 局部进化（简单变异）
    elite_rows=sorted(results, key=lambda r: (-r["总收益(%)"], -r["夏普比"]))[:elite]
    # 定义基因：对 SPACE 的每个维度进行小范围抖动
    def mutate(p):
        q=dict(p)
        for k in space.keys():
            v=q[k]
            if isinstance(v,(int,float)):
                q[k]=float(v)*(1+np.random.normal(0,0.1))
        return q
    for _ in range(n_ga):
        base=np.random.choice(elite_rows)
        cand=mutate(json.loads(base["参数JSON"]))
        results.append(backtest_once(df, strat_key, cand, rp, symbol, tf))
    return results

def walk_forward_validate(df, strat_key, best_params, rp, symbol, tf, kfold=5):
    n=len(df)
    splits=walk_forward_splits(n, k=kfold)
    oos=[]
    for i,(a,b) in enumerate(splits):
        sub=df.iloc[:b].copy()
        res=backtest_once(sub, strat_key, best_params, rp, symbol, tf)
        eq=res["eq"]; oos.append(eq.iloc[-1]-1.0)
    oos_ret=np.array([float(x) for x in oos if pd.notna(x)])
    return (oos_ret.mean()*100.0) if len(oos_ret)>0 else np.nan

def main():
    from utils.gpu_accel import log_env
    log_env()
    ap=argparse.ArgumentParser()
    ap.add_argument("--db", default=get_db_path())
    ap.add_argument("--days", type=int, default=365)
    ap.add_argument("--topk", type=int, default=40)
    ap.add_argument("--outdir", default="results")
    ap.add_argument("--symbols", nargs="+")
    args=ap.parse_args()
    rp=runtime_params()
    os.makedirs(args.outdir, exist_ok=True)
    os.makedirs("data", exist_ok=True)

    # 符号集合
    if args.symbols: symbols=sorted(set(s.upper() for s in args.symbols))
    else:
        # 从库中自动检测存在的表
        with connect_ro(args.db) as con:
            rows=con.execute("SELECT name FROM sqlite_master WHERE type='table'").fetchall()
        got=set()
        for (tb,) in rows:
            if "_" in tb:
                s,tf=tb.split("_",1)
                if tf in TFS: got.add(s)
        symbols=sorted(got)[:80]  # 上限保护

    print(f"[回测] 符号数={len(symbols)} 窗口={args.days}天 S档=ON")

    all_rows=[]
    for s in symbols:
        for tf in TFS:
            df=read_klines(args.db, f"{s}_{tf}")
            if df is None or df.empty: continue
            cutoff=int(pd.Timestamp.utcnow().value//10**6) - args.days*24*3600*1000
            df=df[df["ts"]>=cutoff]
            if len(df)<200: continue
            for strat_key in STRATS.keys():
                rs=bayes_ga_optimize(df, s, tf, strat_key, rp)
                all_rows.extend(rs)

    if not all_rows:
        print("无结果"); return

    # 汇总 → 稳健性/校正
    df_all=pd.DataFrame([{k:v for k,v in r.items() if k not in ["pos","ret","eq"]} for r in all_rows])
    # 以“币×周期×策略×参数”聚合，取收益最高一条（本轮已去重）
    gcols=["Symbol","时间周期","策略","参数JSON"]
    df_best=(df_all.sort_values(["Symbol","时间周期","策略","总收益(%)","夏普比"], ascending=[True,True,True,False,False])
                  .groupby(gcols, as_index=False).head(1))

    # 对每个币保留唯一最佳（多周期自动选优）
    keep=[]
    for sym, g in df_best.groupby("Symbol"):
        best=(g.sort_values(["总收益(%)","夏普比","胜率(%)"], ascending=[False,False,False]).head(1))
        keep.append(best)
    best_per_symbol=pd.concat(keep, ignore_index=True)

    # Walk-Forward、Deflated Sharpe、SPA、PBO
    oos_list=[]; ds_list=[]; spa_list=[]; pbo_list=[]
    for i,row in best_per_symbol.iterrows():
        s=row["Symbol"]; tf=row["时间周期"]; strat=row["策略"]; params=json.loads(row["参数JSON"])
        df=read_klines(args.db, f"{s}_{tf}")
        if df is None: continue
        cutoff=int(pd.Timestamp.utcnow().value//10**6) - args.days*24*3600*1000
        df=df[df["ts"]>=cutoff]
        oos=walk_forward_validate(df, strat, params, rp, s, tf, kfold=5)
        ds=deflated_sharpe(row["夏普比"], n_strats=max(1,len(df_all)), n_obs=len(df))
        # SPA：用该币所有候选的收益分数
        g=df_all[(df_all["Symbol"]==s) & (df_all["时间周期"]==tf)]
        sig,p = spa_significance(g["总收益(%)"].fillna(0).values)
        # PBO：简单以 in/out 排名对比（这里用收益≈代理）
        pbo = probability_of_backtest_overfitting(g["总收益(%)"].rank().values,
                                                  g["夏普比"].rank().values)
        oos_list.append(oos); ds_list.append(ds); spa_list.append("是" if sig else "否"); pbo_list.append(pbo)
    best_per_symbol["样本外收益(%)"]=oos_list
    best_per_symbol["去水分夏普"]=ds_list
    best_per_symbol["SPA显著性(是/否)"]=spa_list
    best_per_symbol["PBO(过拟合概率)"]=pbo_list
    best_per_symbol["稳健性通过(是/否)"]=["是" if (a>=0 and b=="是") else "否" for a,b in zip(oos_list, spa_list)]

    # 导出中文报表
    ts=datetime.now().strftime("%Y%m%d-%H%M%S")
    path1=os.path.join(args.outdir, f"最优组合总表_S档_{ts}.csv")
    path2=os.path.join(args.outdir, f"全量回测明细_S档_{ts}.csv")
    path3=os.path.join(args.outdir, f"参数寻优轨迹_S档_{ts}.csv")
    path4=os.path.join(args.outdir, f"稳健性与检验报告_S档_{ts}.csv")

    best_per_symbol.drop(columns=["pos","ret","eq"], errors="ignore").to_csv(path1, index=False, encoding="utf-8-sig")
    df_all.drop(columns=["pos","ret","eq"], errors="ignore").to_csv(path2, index=False, encoding="utf-8-sig")
    df_all[["Symbol","时间周期","策略","参数JSON","总收益(%)","夏普比","最大回撤(%)","胜率(%)","交易次数"]].to_csv(path3, index=False, encoding="utf-8-sig")
    best_per_symbol[["Symbol","时间周期","策略","参数JSON","样本外收益(%)","去水分夏普","SPA显著性(是/否)","PBO(过拟合概率)","稳健性通过(是/否)"]].to_csv(path4, index=False, encoding="utf-8-sig")

    # best_combo.csv（机器友好，实盘使用）
    os.makedirs("data", exist_ok=True)
    best_combo_path="data/best_combo.csv"
    out_cols=["Symbol","时间周期","策略","参数JSON","总收益(%)","夏普比","最大回撤(%)","胜率(%)","交易次数"]
    best_per_symbol[out_cols].to_csv(best_combo_path, index=False, encoding="utf-8-sig")

    # 简单 PBO 可视化（html）
    try:
        import matplotlib.pyplot as plt
        fig,ax=plt.subplots(figsize=(7,4))
        ax.hist(best_per_symbol["PBO(过拟合概率)"].fillna(0), bins=10)
        ax.set_title("PBO 分布（越低越好）"); ax.set_xlabel("PBO"); ax.set_ylabel("频数")
        html=os.path.join(args.outdir, f"PBO报告_S档_{ts}.html")
        import io, base64
        buf=io.BytesIO(); plt.tight_layout(); plt.savefig(buf, format="png"); data=base64.b64encode(buf.getvalue()).decode()
        with open(html,"w",encoding="utf-8") as f:
            f.write(f"<img src='data:image/png;base64,{data}'/>")
    except Exception:
        pass

    print(f"[完成] 最优表: {path1}")
    print(f"[完成] best_combo: {best_combo_path}")

if __name__=="__main__":
    main()

# === auto override (append): robust resolver for A1-A8 with fuzzy matching ===
from importlib import import_module as _imp
import re as _re

def _resolve_fn(strat_key):
    S = _imp("strategy.strategies_a1a8")
    key = str(strat_key)

    # 1) 直接模块属性
    if hasattr(S, key) and callable(getattr(S, key)):
        return getattr(S, key)

    # 2) 常见注册表/字典
    for k in ("STRATEGIES","STRATEGY_FUNCS","STRAT_TABLE","REGISTRY","ALIASES","ALIAS"):
        if hasattr(S, k):
            M = getattr(S, k)
            try:
                fn = M.get(key) if hasattr(M, "get") else (M[key] if key in M else None)
            except Exception:
                fn = None
            if callable(fn):
                return fn

    # 3) 收集 strat_* 候选
    names = [n for n in dir(S) if n.startswith("strat_") and callable(getattr(S, n, None))]
    low   = {n.lower(): n for n in names}

    # 4) A1~A8 专属映射 + 关键词
    alias_kw = {
        "A1": ["bbands","band"],
        "A2": ["break","don","channel","bo","brk","donch"],
        "A3": ["rsi"],
        "A4": ["macd"],
        "A5": ["kelly"],
        "A6": ["meanrev","mean_rev","revert","mr"],
        "A7": ["trend","ma_cross","cross","sma","ema","adx"],
        "A8": ["mix","combo","blend","stack"],
        "XGB": ["xgb"],
        "LGBM": ["lgb","lightgbm"],
        "LSTM": ["lstm","rnn"],
    }
    up = key.upper()

    # 4.1 直接按 A\d 形态匹配尾缀/变体
    m = _re.fullmatch(r"A(\d+)", up)
    if m:
        num = m.group(1)
        patterns = [
            f"strat_a{num}",
            f"strat_*_a{num}",  # 宽松：名字里含 a{num}
        ]
        for ln, orig in low.items():
            if ln == f"strat_a{num}" or ln.endswith(f"_a{num}") or ln.find(f"a{num}")>=0:
                return getattr(S, orig)

    # 4.2 关键词模糊匹配
    if up in alias_kw:
        kws = alias_kw[up]
        for kw in kws:
            for ln, orig in low.items():
                if kw in ln:
                    return getattr(S, orig)

    # 5) A1 特殊兜底：任何包含 bbands 的策略
    if up == "A1":
        for ln, orig in low.items():
            if "bbands" in ln:
                return getattr(S, orig)

    raise KeyError(f"Unknown strategy: {strat_key}")
